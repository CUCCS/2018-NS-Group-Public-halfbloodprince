# 伪造证书

## HTTPS连接建立

1. Client Hello

    - 支持的协议版本，如 TLS1.0

    - 一个客户端生成的随机数，后面用于生成‘对话密钥’

    - 支持的加密方法，如RSA公钥加密；支持的压缩算法等
   
2. ServerHello

    - 确认使用的加密通信协议版本，如TLS1.0

    - 一个服务器生成的随机数，稍后用于生成‘对话密钥’

    - 确认使用的加密方法，压缩算法等

    - 服务器公钥证书

3. 客户端收到服务器的回应后，首先检查服务器证书的有效性（根证书内嵌在客户端），如果无效则向访问者警告，由其选择是否还要通信。如果有效则提取出服务器公钥，并继续响应：
    - 一个随机数，用服务器公钥加密；编码改变通知，表示随后信息都将用双方商定的加密方法和密钥发送

    - 客户端握手结束通知。发送前面发送的所有内容的hash值，用来供服务器校验

4. 服务器收到客户端的第三个随机数后，计算本次会话的‘会话密钥’（对称密钥），并向客户端发送：

    - 编码改变通知，表示随后信息都将用双方商定的加密方法和密钥发送

    - 握手结束通知。发送前面发送的所有内容的hash值，用来供客户端校验


## 中间人攻击

### 攻击原理

![](image/mitm.png)


## 伪装证书与中间人攻击

### 工具 sslsplit

### 靶机

- IP : 10.0.2.13

- 路由表

    ![](image/bj_route.png)

- ARP

    ![](image/bj_arp.png)


### 攻击者

- IP ：10.0.2.9

## 攻击过程

1. 攻击者生成自签名证书

    - 私钥，以后用来签名伪造证书

    ![](image/private_key.png)

    - 生成CA证书，用来验证伪造证书

    ![](image/public_key.png)

2. 攻击者开启路由转发

    ![](image/route_forward.png)

3. 攻击者配置iptables规则
    
    - 发给80端口的流量转发给8080端口

         `iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080`

    - 发给443端口的流量转发给8443端口

         `iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443`

4. 攻击者对靶机实行ARP欺骗

- 欺骗前

    ![](image/arp_spoof_before.png)

- 欺骗后，网关mac地址变成攻击者mac地址

    ![](image/arp_spoof_sucess.png)

5. 攻击者启动sslsplit,对流量进行日志记录

    `sslsplit -D -l connect.log -j /root/test -S /root/test/logdir -k ca.key -c ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080 `

6. 靶机访问

- 访问github

    - 正常访问

    ![](image/normal_github.png)

    - 伪造证书

    ![](image/github_unsafe.png)

    ![](image/ca_error.png)


     - 若事先攻击者能将自己的CA证书安装到客户端便没有这个警告，如

        ![](image/install_ca.png)

        ![](image/sign.png)


- Add Exception后可正常访问github（攻击需要用户配合）

- 攻击者获取的信息

    - 通过真实证书信息伪造证书

     ![](image/file.png)

    - 通信信息(靶机登录github)

     ![](image/user_pass.png)

## 伪造证书实现中间人攻击的条件

- 对靶机进行ARP欺骗，进行流量劫持

- 靶机用户的安全意识很薄弱，对浏览器弹出的警告置之不理，即攻击需要受害者配合

- 将用于签名伪造证书的私钥所对应的公钥证书提前安装到目标机器，这种情况下没有警告弹出，攻击成功率较高

## 另类伪造证书


- 权威CA自行为某域名签发证书，由于用户浏览器内置受信任CA的根证书，此时进行中间人攻击毫无察觉

- 针对此类伪造证书，提出了Certificate Transparecy(证书透明度)系统用于记录、审计和监控CA颁发的证书

    - 组成部分

        - 证书日志

        - 证书监视

        - 证书审计

    - CA公开宣布其颁发的数字证书或证书所有者宣布其所有的合法证书，即将证书记录到证书日志中，可以给用户查找

    - 证书记录只能被添加，不能被删除、修改或追溯插入日志

    - 证书日志使用‘Mkle Tree Hashes’机制，对于验证所有的证书或某个特定的证书是否已加入日志十分便捷

        - `Merkle Tree Hash`机制原理

            - `Merkle hash tree`是一棵二叉树，叶节点是单个加入日志的证书的哈希值，节点是其子节点的哈希值，根节点即整棵树的哈希值：`Merkle Tree Hash` ，当日志服务器对根节点签名时，根节点称为`signed tree head` (STH).

            ![](image/ct_hash_1.png)

            - 当有新的证书加入日志中时，生成一棵新的`Merkle hash tree`，然后将新的`Merkle hash tree`与之前的`Merkle hash tree`合并

            ![](image/ct_hash_2.png)

            - 一致性验证 

                - 老的`Merkle Tree Hash`是新的`Merkle Tree Hash`的子集

                - 新的`Merkle Tree Hash`是老的`Merkle Tree Hash`和新加入证书哈希值的汇总




    - 公开审计，任何人都可以查询日志，或者验证颁发的数字证书是否已经合理的记录在日志中

        
        - 如要验证证书d3是否是合法证书，需要用到节点c,i,n，d3已知，利用c计算出j,i和j计算出m,m和n计算出`Merkle Tree Hash`，计算出的`Merkle Tree Hash`与当前的`Merkle Tree Hash`一致，说明证书d3已被加入日志中，属于合法证书

        ![](image/ct_hash_5.png)


    - 此方法虽然不能阻止CA伪造证书，但能帮助用户尽快发现伪造的证书

        ![](image/ct.png)


# 引用


- [如何应对伪造的SSL证书](https://www.freebuf.com/vuls/101479.html)

- [SSL中间人证书攻击](https://www.freebuf.com/sectool/48016.html)

- [SSL/TSL原理详解](https://segmentfault.com/a/1190000002554673)

- [How Log Proofs Work](https://www.certificate-transparency.org/log-proofs-work)



    

    





